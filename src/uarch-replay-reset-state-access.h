// Copyright Cartesi and individual authors (see AUTHORS)
// SPDX-License-Identifier: LGPL-3.0-or-later
//
// This program is free software: you can redistribute it and/or modify it under
// the terms of the GNU Lesser General Public License as published by the Free
// Software Foundation, either version 3 of the License, or (at your option) any
// later version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT ANY
// WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
// PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License along
// with this program (see COPYING). If not, see <https://www.gnu.org/licenses/>.
//

#ifndef UARCH_REPLAY_RESET_STATE_ACCESS_H
#define UARCH_REPLAY_RESET_STATE_ACCESS_H

/// \file
/// \brief State access implementation that replays recorded state accesses

#include <boost/container/static_vector.hpp>
#include <cassert>
#include <iomanip>
#include <memory>
#include <sstream>
#include <string>

#include "i-uarch-reset-state-access.h"
#include "uarch-pristine-state-hash.h"

namespace cartesi {

/// \brief Allows replaying a uarch reset operation from an access log.
class uarch_replay_reset_state_access : public i_uarch_reset_state_access<uarch_replay_reset_state_access> {
    using tree_type = machine_merkle_tree;
    using hash_type = tree_type::hash_type;
    using hasher_type = tree_type::hasher_type;
    using proof_type = tree_type::proof_type;

    ///< Access log generated by log_uarch_reset
    const std::vector<access> &m_accesses;
    ///< Whether to verify proofs in access log
    bool m_verify_proofs;
    ///< Index of next access to ne consumed
    unsigned m_next_access;
    ///< Add to indices reported in errors
    int m_one_based;
    ///< Root hash before next access
    machine_merkle_tree::hash_type m_root_hash;
    ///< Hasher needed to verify proofs
    machine_merkle_tree::hasher_type m_hasher;

public:
    /// \brief Constructor from access log
    /// \param log Access log to be replayed
    /// \param verify_proofs Whether to verify proofs in access log
    /// \param one_based Whether to add one to indices reported in errors
    explicit uarch_replay_reset_state_access(const access_log &log, bool verify_proofs, bool one_based) :
        m_accesses(log.get_accesses()),
        m_verify_proofs(verify_proofs),
        m_next_access{0},
        m_one_based{one_based},
        m_root_hash{},
        m_hasher{} {
        if (m_verify_proofs && !log.get_log_type().has_proofs()) {
            throw std::invalid_argument{"log has no proofs"};
        }
        if (log.get_accesses().size() != 1) {
            throw std::invalid_argument{"there must be one access in log"};
        }
        if (m_verify_proofs) {
            const auto &access = m_accesses.front();
            if (!access.get_proof().has_value()) {
                throw std::invalid_argument{"initial access has no proof"};
            }
            m_root_hash = access.get_proof().value().get_root_hash(); // NOLINT(bugprone-unchecked-optional-access)
        }
    }

    /// \brief No copy constructor
    uarch_replay_reset_state_access(const uarch_replay_reset_state_access &) = delete;
    /// \brief No copy assignment
    uarch_replay_reset_state_access &operator=(const uarch_replay_reset_state_access &) = delete;
    /// \brief No move constructor
    uarch_replay_reset_state_access(uarch_replay_reset_state_access &&) = delete;
    /// \brief No move assignment
    uarch_replay_reset_state_access &operator=(uarch_replay_reset_state_access &&) = delete;
    /// \brief Default destructor
    ~uarch_replay_reset_state_access() = default;

    void get_root_hash(machine_merkle_tree::hash_type &hash) const {
        hash = m_root_hash;
    }

    /// \brief Checks if access log was fully consumed after reset operation is finished
    void finish(void) {
        if (m_next_access != m_accesses.size()) {
            throw std::invalid_argument{"access log was not fully consumed"};
        }
    }

private:
    static void roll_hash_up_tree(machine_merkle_tree::hasher_type &hasher,
        const machine_merkle_tree::proof_type &proof, machine_merkle_tree::hash_type &rolling_hash) {
        for (int log2_size = proof.get_log2_target_size(); log2_size < proof.get_log2_root_size(); ++log2_size) {
            const int bit = (proof.get_target_address() & (UINT64_C(1) << log2_size)) != 0;
            const auto &sibling_hash = proof.get_sibling_hash(log2_size);
            hasher.begin();
            if (bit) {
                hasher.add_data(sibling_hash.data(), sibling_hash.size());
                hasher.add_data(rolling_hash.data(), rolling_hash.size());
            } else {
                hasher.add_data(rolling_hash.data(), rolling_hash.size());
                hasher.add_data(sibling_hash.data(), sibling_hash.size());
            }
            hasher.end(rolling_hash);
        }
    }

    friend i_uarch_reset_state_access<uarch_replay_reset_state_access>;

    // NOLINTNEXTLINE(readability-convert-member-functions-to-static)
    void do_push_bracket(bracket_type type, const char *text) {
        (void) type;
        (void) text;
    }

    int do_make_scoped_note(const char *text) { // NOLINT(readability-convert-member-functions-to-static)
        (void) text;
        return 0;
    }

    auto access_to_report(void) const {
        return m_next_access + m_one_based;
    }

    void do_reset_state(void) {
        hasher_type hasher;
        auto text = std::string("uarchState");
        if (m_next_access >= m_accesses.size()) {
            throw std::invalid_argument{"too few accesses in log"};
        }
        const auto &access = m_accesses[m_next_access];
        if (access.get_type() != access_type::write) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to write " + text};
        }
        if (access.get_address() != UARCH_STATE_START_ADDRESS) {
            throw std::invalid_argument{"expected address of access " + std::to_string(access_to_report()) +
                " to be the start address of the uarch state"};
        }
        if (access.get_log2_size() != UARCH_STATE_LOG2_SIZE) {
            throw std::invalid_argument{"expected access " + std::to_string(access_to_report()) + " to write 2^" +
                std::to_string(UARCH_STATE_LOG2_SIZE) + " bytes from " + text};
        }
        if (access.get_read().has_value()) {
            // if read data is available then its hash and the logged read hash must match
            hash_type computed_hash;
            get_hash(hasher, access.get_read().value().data(), access.get_read().value().size(), computed_hash);
            if (computed_hash != access.get_read_hash()) {
                throw std::invalid_argument{"hash of read data and read hash at access " +
                    std::to_string(access_to_report()) + " does not match read hash"};
            }
        }
        if (!access.get_written_hash().has_value()) {
            throw std::invalid_argument{"write access " + std::to_string(access_to_report()) + " has no written hash"};
        }
        if (access.get_written().has_value()) {
            // if written data is available then its hash and the logged written hash must match
            hash_type computed_hash;
            get_hash(hasher, access.get_written().value().data(), access.get_written().value().size(), computed_hash);
            if (computed_hash != access.get_written_hash().value()) {
                throw std::invalid_argument{
                    "written hash and written data mismatch at access " + std::to_string(access_to_report())};
            }
        }
        if (m_verify_proofs) {
            if (!access.get_proof().has_value()) {
                throw std::invalid_argument{"write access " + std::to_string(access_to_report()) + " has no proof"};
            }
            const auto &proof = access.get_proof().value(); // NOLINT(bugprone-unchecked-optional-access)
            if (proof.get_target_address() != access.get_address()) {
                throw std::invalid_argument{"mismatch in write access " + std::to_string(access_to_report()) +
                    " address and its proof address"};
            }
            if (m_root_hash != proof.get_root_hash()) {
                throw std::invalid_argument{
                    "mismatch in write access " + std::to_string(access_to_report()) + " root hash"};
            }
            auto rolling_hash = access.get_read_hash();
            if (rolling_hash != proof.get_target_hash()) {
                throw std::invalid_argument{
                    "value before write access " + std::to_string(access_to_report()) + " does not match target hash"};
            }
            roll_hash_up_tree(m_hasher, proof, rolling_hash);
            if (rolling_hash != proof.get_root_hash()) {
                throw std::invalid_argument{
                    "value before write access " + std::to_string(access_to_report()) + " fails proof"};
            }
            // computes the new root hash by rolling up the write hash
            m_root_hash = access.get_written_hash().value();
            roll_hash_up_tree(m_hasher, proof, m_root_hash);
        }
        if (access.get_written_hash().value() != uarch_pristine_state_hash) {
            throw std::invalid_argument{"expected written hash of access " + std::to_string(access_to_report()) +
                " to be the start hash of the pristine uarch state"};
        }
        m_next_access++;
    }

    static void get_hash(hasher_type &hasher, const unsigned char *data, size_t len, hash_type &hash) {
        if (len <= 8) {
            assert(len == 8);
            hasher.begin();
            hasher.add_data(data, len);
            hasher.end(hash);
        } else {
            assert((len & 1) == 0);
            len = len / 2;
            hash_type left;
            get_hash(hasher, data, len, left);
            get_hash(hasher, data + len, len, hash);
            hasher.begin();
            hasher.add_data(left.data(), left.size());
            hasher.add_data(hash.data(), hash.size());
            hasher.end(hash);
        }
    }
};

} // namespace cartesi

#endif
